%!TEX root = std.tex

\rSec2[unique.ptr]{Class template \tcode{unique_ptr}}

\pnum
A \defn{unique pointer} is an object that owns another object and
manages that other object through a pointer. More precisely, a unique pointer
is an object \textit{u} that stores a pointer to a second object \textit{p} and
will dispose of \textit{p} when \textit{u} is itself destroyed (e.g., when
leaving block scope~(\ref{stmt.dcl})). In this context, \textit{u} is said
to \defn{own} \tcode{p}.

\pnum
The mechanism by which \textit{u} disposes of \textit{p} is known as
\textit{p}'s associated \defn{deleter}, a function object whose correct
invocation results in \textit{p}'s appropriate disposition (typically its deletion).

\pnum
Let the notation \textit{u.p} denote the pointer stored by \textit{u}, and
let \textit{u.d} denote the associated deleter. Upon request, \textit{u} can
\defn{reset} (replace) \textit{u.p} and \textit{u.d} with another pointer and
deleter, but must properly dispose of its owned object via the associated
deleter before such replacement is considered completed.

\pnum
Additionally, \textit{u} can, upon request, \defn{transfer ownership} to another
unique pointer \textit{u2}. Upon completion of such a transfer, the following
postconditions hold:

\begin{itemize}
\item \textit{u2.p} is equal to the pre-transfer \textit{u.p},
\item \textit{u.p} is equal to \tcode{nullptr}, and
\item if the pre-transfer \textit{u.d} maintained state, such state has been
transferred to \textit{u2.d}.
\end{itemize}

As in the case of a reset, \textit{u2} must properly dispose of its pre-transfer
owned object via the pre-transfer associated deleter before the ownership
transfer is considered complete. \enternote A deleter's state need never be
copied, only moved or swapped as ownership is transferred. \exitnote

\pnum
Each object of a type \tcode{U} instantiated from the \tcode{unique_ptr} template
specified in this subclause has the strict ownership semantics, specified above,
of a unique pointer. In partial satisfaction of these semantics, each such \tcode{U}
is \tcode{MoveConstructible} and \tcode{MoveAssignable}, but is not
\tcode{CopyConstructible} nor \tcode{CopyAssignable}.
The template parameter \tcode{T} of \tcode{unique_ptr} may be an incomplete type.

\pnum
\enternote The uses
of \tcode{unique_ptr} include providing exception safety for
dynamically allocated memory, passing ownership of dynamically allocated
memory to a function, and returning dynamically allocated memory from a
function. \exitnote

\begin{codeblock}
namespace std {
  template<class T> struct default_delete;
  template<class T> struct default_delete<T[]>;

  template<class T, class D = default_delete<T>> class unique_ptr;
  template<class T, class D> class unique_ptr<T[], D>;

  template<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);
  template<class T> unique_ptr<T> make_unique(size_t n);
  template<class T, class... Args> @\unspec@ make_unique(Args&&...) = delete;

  template<class T, class D> void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;

  template<class T1, class D1, class T2, class D2>
    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
  template<class T1, class D1, class T2, class D2>
    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

  template <class T, class D>
    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;
  template <class T, class D>
    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;
  template <class T, class D>
    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;
  template <class T, class D>
    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;
  template <class T, class D>
    bool operator<(const unique_ptr<T, D>& x, nullptr_t);
  template <class T, class D>
    bool operator<(nullptr_t, const unique_ptr<T, D>& y);
  template <class T, class D>
    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);
  template <class T, class D>
    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);
  template <class T, class D>
    bool operator>(const unique_ptr<T, D>& x, nullptr_t);
  template <class T, class D>
    bool operator>(nullptr_t, const unique_ptr<T, D>& y);
  template <class T, class D>
    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);
  template <class T, class D>
    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);

}
\end{codeblock}

\rSec3[unique.ptr.dltr]{Default deleters}

\rSec4[unique.ptr.dltr.general]{In general}

\pnum
The class template \tcode{default_delete} serves as the default deleter (destruction policy)
for the class template \tcode{unique_ptr}.

\pnum
The template parameter \tcode{T} of \tcode{default_delete} may be
an incomplete type.

\rSec4[unique.ptr.dltr.dflt]{\tcode{default_delete}}

\begin{codeblock}
namespace std {
  template <class T> struct default_delete {
    constexpr default_delete() noexcept = default;
    template <class U> default_delete(const default_delete<U>&) noexcept;
    void operator()(T*) const;
  };
}
\end{codeblock}

\indexlibrary{\idxcode{default_delete}!\idxcode{default_delete}}
\indexlibrary{\idxcode{default_delete}!\idxcode{default_delete}}
\begin{itemdecl}
template <class U> default_delete(const default_delete<U>& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{default_delete} object
from another \tcode{default_delete<U>} object.

\pnum
\remarks This constructor shall not participate in overload resolution unless
\tcode{U*} is implicitly convertible to \tcode{T*}.
\end{itemdescr}

\indexlibrary{\idxcode{operator()}!\idxcode{default_delete}}
\indexlibrary{\idxcode{default_delete}!\idxcode{operator()}}
\begin{itemdecl}
void operator()(T* ptr) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects calls \tcode{delete} on \tcode{ptr}.

\pnum
\notes If \tcode{T} is an incomplete type, the program is ill-formed.
\end{itemdescr}

\rSec4[unique.ptr.dltr.dflt1]{\tcode{default_delete<T[]>}}

\begin{codeblock}
namespace std {
  template <class T> struct default_delete<T[]> {
    constexpr default_delete() noexcept = default;
    void operator()(T*) const;
    template <class U> void operator()(U*) const = delete;
  };
}
\end{codeblock}

\indexlibrary{\idxcode{operator()}!\idxcode{default_delete}}
\indexlibrary{\idxcode{default_delete}!\idxcode{operator()}}
\begin{itemdecl}
void operator()(T* ptr) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
calls \tcode{delete[]} on \tcode{ptr}.

\pnum
\notes If T is an incomplete type, the program is ill-formed.
\end{itemdescr}

\rSec3[unique.ptr.single]{\tcode{unique_ptr} for single objects}

\begin{codeblock}
namespace std {
  template <class T, class D = default_delete<T>> class unique_ptr {
  public:
    typedef @\seebelow@ pointer;
    typedef T element_type;
    typedef D deleter_type;

    // \ref{unique.ptr.single.ctor}, constructors
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, @\seebelow@ d1) noexcept;
    unique_ptr(pointer p, @\seebelow@ d2) noexcept;
    unique_ptr(unique_ptr&& u) noexcept;
    constexpr unique_ptr(nullptr_t) noexcept
      : unique_ptr() { }
    template <class U, class E>
      unique_ptr(unique_ptr<U, E>&& u) noexcept;
    template <class U>
      unique_ptr(auto_ptr<U>&& u) noexcept;

    // \ref{unique.ptr.single.dtor}, destructor
    ~unique_ptr();

    // \ref{unique.ptr.single.asgn}, assignment
    unique_ptr& operator=(unique_ptr&& u) noexcept;
    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
    unique_ptr& operator=(nullptr_t) noexcept;

    // \ref{unique.ptr.single.observers}, observers
    add_lvalue_reference_t<T> operator*() const;
    pointer operator->() const noexcept;
    pointer get() const noexcept;
    deleter_type& get_deleter() noexcept;
    const deleter_type& get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    // \ref{unique.ptr.single.modifiers} modifiers
    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void swap(unique_ptr& u) noexcept;

    // disable copy from lvalue
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
  };
}
\end{codeblock}

\pnum
The default type for the template parameter \tcode{D} is
\tcode{default_delete}. A client-supplied template argument
\tcode{D} shall be a function
object type~(\ref{function.objects}), lvalue-reference to function, or
lvalue-reference to function object type
for which, given
a value \tcode{d} of type \tcode{D} and a value
\tcode{ptr} of type \tcode{unique_ptr<T, D>::pointer}, the expression
\tcode{d(ptr)} is valid and has the effect of disposing of the
pointer as appropriate for that deleter.

\pnum
If the deleter's type \tcode{D} is not a reference type, \tcode{D} shall satisfy
the requirements of \tcode{Destructible} (Table~\ref{destructible}).

\pnum
If the type \tcode{remove_reference_t<D>::pointer} exists, then \tcode{unique_ptr<T,
D>::pointer} shall be a synonym for \tcode{remove_reference_t<D>::pointer}. Otherwise
\tcode{unique_ptr<T, D>::pointer} shall be a synonym for \tcode{T*}. The type \tcode{unique_ptr<T,
D>::pointer} shall
satisfy the requirements of \tcode{NullablePointer} (\ref{nullablepointer.requirements}).

\pnum
\enterexample Given an allocator type \tcode{X}~(\ref{allocator.requirements}) and
letting \tcode{A} be a synonym for \tcode{allocator_traits<X>}, the types \tcode{A::pointer},
\tcode{A::const_pointer}, \tcode{A::void_pointer}, and \tcode{A::const_void_pointer}
may be used as \tcode{unique_ptr<T, D>::pointer}. \exitexample

\rSec4[unique.ptr.single.ctor]{\tcode{unique_ptr} constructors}

\indexlibrary{\idxcode{unique_ptr}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{unique_ptr}}
\begin{itemdecl}
constexpr unique_ptr() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{D} shall
satisfy the requirements of \tcode{DefaultConstructible} (Table~\ref{defaultconstructible}),
and that construction shall not throw an exception.

\pnum
\effects Constructs a \tcode{unique_ptr} object that owns
nothing, value-initializing the stored pointer and the stored deleter.

\pnum
\postconditions \tcode{get() == nullptr}. \tcode{get_deleter()}
returns a reference to the stored deleter.

\pnum
\notes If this constructor is instantiated with a pointer type or reference type
for the template argument \tcode{D}, the program is ill-formed.
\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{unique_ptr}}
\begin{itemdecl}
explicit unique_ptr(pointer p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{D} shall
satisfy the requirements of \tcode{DefaultConstructible} (Table~\ref{defaultconstructible}),
and that construction shall not throw an exception.

\pnum
\effects Constructs a \tcode{unique_ptr} which owns
\tcode{p}, initializing the stored pointer with \tcode{p} and
value-initializing the stored deleter.

\pnum
\postconditions \tcode{get() == p}. \tcode{get_deleter()}
returns a reference to the stored deleter.

\pnum
\notes If this constructor is instantiated with a pointer type or reference type
for the template argument \tcode{D}, the program is ill-formed.
\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{unique_ptr}}
\begin{itemdecl}
unique_ptr(pointer p, @\seebelow@ d1) noexcept;
unique_ptr(pointer p, @\seebelow@ d2) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
The signature of these constructors depends upon whether \tcode{D}
is a reference type. If \tcode{D} is non-reference type
\tcode{A}, then the signatures are:

\begin{codeblock}
unique_ptr(pointer p, const A& d);
unique_ptr(pointer p, A&& d);
\end{codeblock}

\pnum
If \tcode{D} is an lvalue-reference type \tcode{A\&},
then the signatures are:

\begin{codeblock}
unique_ptr(pointer p, A& d);
unique_ptr(pointer p, A&& d);
\end{codeblock}

\pnum
If \tcode{D} is an lvalue-reference type \tcode{const A\&},
then the signatures are:

\begin{codeblock}
unique_ptr(pointer p, const A& d);
unique_ptr(pointer p, const A&& d);
\end{codeblock}

\pnum
\requires
\begin{itemize}
\item If \tcode{D} is not an lvalue-reference type then

\begin{itemize}
\item If \tcode{d} is an lvalue or \tcode{const} rvalue then
the first constructor of this pair will be selected. \tcode{D}
shall satisfy the requirements of
\tcode{CopyConstructible} (Table~\ref{copyconstructible}), and
the copy constructor of \tcode{D} shall
not throw an exception.
This \tcode{unique_ptr} will hold
a copy of \tcode{d}.

\item Otherwise, \tcode{d} is a non-const rvalue and the second
constructor of this pair will be selected. \tcode{D}
shall satisfy the requirements of
\tcode{MoveConstructible} (Table~\ref{moveconstructible}), and the
move constructor of \tcode{D} shall not throw an exception.
This \tcode{unique_ptr} will
hold a value move constructed from \tcode{d}.
\end{itemize}

\item Otherwise \tcode{D} is an lvalue-reference type. \tcode{d}
shall be reference-compatible with one of the constructors. If \tcode{d} is
an rvalue, it will bind to the second constructor of this pair and the program is
ill-formed. \enternote The diagnostic could
be implemented using a \tcode{static_assert} which assures that
\tcode{D} is not a reference type. \exitnote Else \tcode{d}
is an lvalue and will bind to the first constructor of this pair. The type
which \tcode{D} references need not be \tcode{CopyConstructible}
nor \tcode{MoveConstructible}. This \tcode{unique_ptr} will
hold a \tcode{D} which refers to the lvalue \tcode{d}.
\enternote \tcode{D} may not be an rvalue-reference type.
\exitnote
\end{itemize}

\pnum
\effects Constructs a \tcode{unique_ptr} object which owns \tcode{p}, initializing
the stored pointer with \tcode{p} and initializing the deleter as described above.

\pnum
\postconditions \tcode{get() == p}.
\tcode{get_deleter()} returns a reference to the stored
deleter. If \tcode{D} is a reference type then \tcode{get_deleter()}
returns a reference to the lvalue \tcode{d}.

\enterexample

\begin{codeblock}
D d;
unique_ptr<int, D> p1(new int, D());        // \tcode{D} must be \tcode{MoveConstructible}
unique_ptr<int, D> p2(new int, d);          // \tcode{D} must be \tcode{CopyConstructible}
unique_ptr<int, D&> p3(new int, d);         // \tcode{p3} holds a reference to \tcode{d}
unique_ptr<int, const D&> p4(new int, D()); // error: rvalue deleter object combined
                                            // with reference deleter type
\end{codeblock}

\exitexample

\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
unique_ptr(unique_ptr&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{D} is not a reference type,
\tcode{D} shall satisfy the requirements of \tcode{MoveConstructible}
(Table~\ref{moveconstructible}).
Construction
of the deleter from an rvalue of type \tcode{D} shall not
throw an exception.

\pnum
\effects Constructs a \tcode{unique_ptr} by transferring ownership from
\tcode{u} to \tcode{*this}. If \tcode{D} is a reference type, this
deleter is copy constructed from \tcode{u}'s deleter; otherwise, this
deleter is move constructed from \tcode{u}'s deleter. \enternote The
deleter constructor can be implemented with \tcode{std::forward<D>}. \exitnote

\pnum
\postconditions \tcode{get()} yields the value \tcode{u.get()}
yielded before the construction. \tcode{get_deleter()} returns a reference
to the stored deleter that was constructed from
\tcode{u.get_deleter()}. If \tcode{D} is a reference type then
\tcode{get_deleter()} and \tcode{u.get_deleter()} both reference
the same lvalue deleter.
\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
template <class U, class E> unique_ptr(unique_ptr<U, E>&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{E} is not a reference type,
construction of the deleter from an rvalue of type
\tcode{E} shall be well formed and shall not throw an exception.
Otherwise, \tcode{E} is a reference type and construction of the deleter from an
lvalue of type \tcode{E} shall be well formed and shall not throw an exception.

\pnum
\remarks This constructor shall not participate in overload resolution unless:

\begin{itemize}
\item \tcode{unique_ptr<U, E>::pointer} is implicitly convertible to \tcode{pointer},
\item \tcode{U} is not an array type, and
\item either \tcode{D} is a reference type and \tcode{E} is the same type as \tcode{D}, or
\tcode{D} is not a reference type and \tcode{E} is implicitly convertible to \tcode{D}.
\end{itemize}

\pnum
\effects Constructs a \tcode{unique_ptr} by transferring ownership from \tcode{u}
to \tcode{*this}. If \tcode{E} is a reference type, this deleter is copy constructed from
\tcode{u}'s deleter; otherwise, this deleter is move constructed from \tcode{u}'s
deleter. \enternote The deleter constructor can be implemented with
\tcode{std::forward<E>}. \exitnote

\pnum
\postconditions \tcode{get()} yields the value \tcode{u.get()}
yielded before the construction.
\tcode{get_deleter()} returns a reference
to the stored deleter that was constructed from
\tcode{u.get_deleter()}.
\end{itemdescr}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
template <class U>
  unique_ptr(auto_ptr<U>&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{unique_ptr} object, initializing the
stored pointer with \tcode{u.release()} and value-initializing the stored deleter.

\pnum
\postconditions \tcode{get()} yields the value \tcode{u.get()} yielded
before the construction.
\tcode{u.get() == nullptr}.
\tcode{get_deleter()} returns a reference to the stored deleter.

\pnum
\remarks This constructor shall not participate in overload resolution unless
\tcode{U*} is implicitly convertible to \tcode{T*} and \tcode{D} is
the same type as \tcode{default_delete<T>}.
\end{itemdescr}

\rSec4[unique.ptr.single.dtor]{\tcode{unique_ptr} destructor}

\indexlibrary{\idxcode{unique_ptr}!destructor}
\begin{itemdecl}
~unique_ptr();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The expression \tcode{get_deleter()(get())} shall be well formed,
shall have well-defined behavior, and shall not throw exceptions. \enternote The
use of \tcode{default_delete} requires \tcode{T} to be a complete type.
\exitnote

\pnum
\effects If \tcode{get() == nullptr} there are no effects.
Otherwise \tcode{get_deleter()(get())}.
\end{itemdescr}

\rSec4[unique.ptr.single.asgn]{\tcode{unique_ptr} assignment}

\indexlibrary{\idxcode{operator=}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator=}}
\begin{itemdecl}
unique_ptr& operator=(unique_ptr&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{D} is not a reference type, \tcode{D} shall satisfy the
requirements of \tcode{MoveAssignable} (Table~\ref{moveassignable}) and assignment
of the deleter from an rvalue of type \tcode{D} shall not throw an exception.
Otherwise, \tcode{D} is a reference type;
\tcode{remove_reference_t<D>} shall satisfy the \tcode{CopyAssignable}
requirements and assignment of the deleter from an
lvalue of type \tcode{D} shall not throw an exception.

\pnum
\effects
Transfers ownership from \tcode{u} to \tcode{*this} as if by calling
\tcode{reset(u.release())} followed by
\tcode{get_deleter() = std::forward<D>(u.get_deleter())}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator=}}
\begin{itemdecl}
template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{E} is not a reference type, assignment of the deleter from
an rvalue of type \tcode{E} shall be well-formed and shall not throw an exception.
Otherwise, \tcode{E} is a reference type and assignment of the deleter from an lvalue
of type \tcode{E} shall be well-formed and shall not throw an exception.

\pnum
\remarks This operator shall not participate in overload resolution unless:

\begin{itemize}
\item \tcode{unique_ptr<U, E>::pointer} is implicitly convertible to \tcode{pointer} and
\item \tcode{U} is not an array type.
\end{itemize}

\pnum
\effects Transfers ownership from \tcode{u} to \tcode{*this} as if by calling
\tcode{reset(u.release())} followed by
\tcode{get_deleter() = std::forward<E>(u.get_deleter())}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator=}}
\begin{itemdecl}
unique_ptr& operator=(nullptr_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{reset()}.

\pnum
\postcondition \tcode{get() == nullptr}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec4[unique.ptr.single.observers]{\tcode{unique_ptr} observers}

\indexlibrary{\idxcode{operator*}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator*}}
\begin{itemdecl}
add_lvalue_reference_t<T> operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{get() != nullptr}.

\pnum
\returns \tcode{*get()}.

\end{itemdescr}

\indexlibrary{\idxcode{operator->}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator->}}
\begin{itemdecl}
pointer operator->() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{get() != nullptr}.

\pnum
\returns \tcode{get()}.

\pnum
\realnote use typically requires that \tcode{T} be a complete type.
\end{itemdescr}

\indexlibrary{\idxcode{get}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{get}}
\begin{itemdecl}
pointer get() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns The stored pointer.
\end{itemdescr}

\indexlibrary{\idxcode{get_deleter}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{get_deleter}}
\begin{itemdecl}
deleter_type& get_deleter() noexcept;
const deleter_type& get_deleter() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A reference to the stored deleter.
\end{itemdescr}

\indexlibrary{\idxcode{operator bool}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator bool}}
\begin{itemdecl}
explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{get() != nullptr}.
\end{itemdescr}

\rSec4[unique.ptr.single.modifiers]{\tcode{unique_ptr} modifiers}

\indexlibrary{\idxcode{release}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{release}}
\begin{itemdecl}
pointer release() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\postcondition \tcode{get() == nullptr}.

\pnum
\returns The value \tcode{get()} had at the start of
the call to \tcode{release}.
\end{itemdescr}

\indexlibrary{\idxcode{reset}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{reset}}
\begin{itemdecl}
void reset(pointer p = pointer()) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The expression \tcode{get_deleter()(get())} shall be well formed, shall have
well-defined behavior, and shall not throw exceptions.

\pnum
\effects assigns \tcode{p} to the stored pointer, and then if the old value of the
stored pointer, \tcode{old_p}, was not equal to \tcode{nullptr}, calls
\tcode{get_deleter()(old_p)}. \enternote The order of these operations is significant
because the call to \tcode{get_deleter()} may destroy \tcode{*this}. \exitnote

\pnum
\postconditions \tcode{get() == p}.
\enternote The postcondition does not hold if the call to \tcode{get_deleter()}
destroys \tcode{*this} since \tcode{this->get()} is no longer a valid expression.
\exitnote
\end{itemdescr}

\indexlibrary{\idxcode{swap}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{swap}}
\begin{itemdecl}
void swap(unique_ptr& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{get_deleter()} shall be
swappable~(\ref{swappable.requirements}) and shall
not throw an exception
under \tcode{swap}.

\pnum
\effects Invokes \tcode{swap} on the stored pointers and on the stored
deleters of \tcode{*this} and \tcode{u}.
\end{itemdescr}

\rSec3[unique.ptr.runtime]{\tcode{unique_ptr} for array objects with a runtime length}

\begin{codeblock}
namespace std {
  template <class T, class D> class unique_ptr<T[], D> {
  public:
    typedef @\seebelow@ pointer;
    typedef T element_type;
    typedef D deleter_type;

    // \ref{unique.ptr.runtime.ctor}, constructors
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, @\seebelow@ d) noexcept;
    unique_ptr(pointer p, @\seebelow@ d) noexcept;
    unique_ptr(unique_ptr&& u) noexcept;
    constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }

    // destructor
    ~unique_ptr();

    // assignment
    unique_ptr& operator=(unique_ptr&& u) noexcept;
    unique_ptr& operator=(nullptr_t) noexcept;

    // \ref{unique.ptr.runtime.observers}, observers
    T& operator[](size_t i) const;
    pointer get() const noexcept;
    deleter_type& get_deleter() noexcept;
    const deleter_type& get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    // \ref{unique.ptr.runtime.modifiers} modifiers
    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void reset(nullptr_t) noexcept;
    template <class U> void reset(U) = delete;
    void swap(unique_ptr& u) noexcept;

    // disable copy from lvalue
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
  };
}
\end{codeblock}

\pnum
A specialization for array types is provided with a slightly altered
interface.

\begin{itemize}
\item Conversions between different types of
\tcode{unique_ptr<T[], D>} or to or from the non-array forms of
\tcode{unique_ptr} produce an ill-formed program.

\item Pointers to types derived from \tcode{T} are
rejected by the constructors, and by \tcode{reset}.

\item The observers \tcode{operator*} and
\tcode{operator->} are not provided.

\item The indexing observer \tcode{operator[]} is provided.

\item The default deleter will call \tcode{delete[]}.
\end{itemize}

\pnum
Descriptions are provided below only for member functions that
have behavior different from the primary template.

\pnum
The template argument \tcode{T} shall be a complete type.

\rSec4[unique.ptr.runtime.ctor]{\tcode{unique_ptr} constructors}

\indexlibrary{\idxcode{unique_ptr}!constructor}%
\begin{itemdecl}
explicit unique_ptr(pointer p) noexcept;
unique_ptr(pointer p, @\seebelow@ d) noexcept;
unique_ptr(pointer p, @\seebelow@ d) noexcept;
\end{itemdecl}

\begin{itemdescr}
These constructors behave the same as in the primary template
except that they do not accept pointer types which are convertible
to \tcode{pointer}. \enternote One implementation technique
is to create private templated overloads of these members. \exitnote
\end{itemdescr}

\rSec4[unique.ptr.runtime.observers]{\tcode{unique_ptr} observers}

\indexlibrary{\idxcode{operator[]}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator[]}}
\begin{itemdecl}
T& operator[](size_t i) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{i <} the
number of elements in the array to which
the stored pointer points.

\pnum
\returns \tcode{get()[i]}.
\end{itemdescr}

\rSec4[unique.ptr.runtime.modifiers]{\tcode{unique_ptr} modifiers}

\indexlibrary{\idxcode{reset}!\idxcode{unique_ptr}}
\indexlibrary{\idxcode{unique_ptr}!\idxcode{reset}}
\begin{itemdecl}
void reset(nullptr_t p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{reset(pointer())}.
\end{itemdescr}

\rSec3[unique.ptr.create]{\tcode{unique_ptr} creation}

\indexlibrary{\idxcode{make_unique}}
\begin{itemdecl}
template <class T, class... Args> unique_ptr<T> make_unique(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution unless \tcode{T} is not an array.

\pnum
\returns \tcode{unique_ptr<T>(new T(std::forward<Args>(args)...))}.

\end{itemdescr}

\begin{itemdecl}
template <class T> unique_ptr<T> make_unique(size_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution unless \tcode{T} is an array of unknown bound.

\pnum
\returns \tcode{unique_ptr<T>(new remove_extent_t<T>[n]())}.

\end{itemdescr}

\begin{itemdecl}
template <class T, class... Args> @\unspec@ make_unique(Args&&...) = delete;
\end{itemdecl}

\begin{itemdescr}
\pnum
\remarks This function shall not participate in overload resolution unless \tcode{T} is an array of known bound.

\end{itemdescr}

\rSec3[unique.ptr.special]{\tcode{unique_ptr} specialized algorithms}

\indexlibrary{\idxcode{swap(unique_ptr\&, unique_ptr\&)}}
\begin{itemdecl}
template <class T, class D> void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Calls \tcode{x.swap(y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator==}}%
\begin{itemdecl}
template <class T1, class D1, class T2, class D2>
  bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.get() == y.get()}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class T1, class D1, class T2, class D2>
  bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.get() != y.get()}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator<}}%
\begin{itemdecl}
template <class T1, class D1, class T2, class D2>
  bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires Let \tcode{CT} be \tcode{common_type<unique_ptr<T1, D1>::pointer,}
\tcode{unique_ptr<T2, D2>::poin\-ter>::type}. Then the specialization
\tcode{less<CT>} shall be a function object type~(\ref{function.objects}) that
induces a strict weak ordering~(\ref{alg.sorting}) on the pointer values.

\pnum
\returns \tcode{less<CT>()(x.get(), y.get()).}

\pnum
\remarks If \tcode{unique_ptr<T1, D1>::pointer} is not implicitly convertible
to \tcode{CT} or \tcode{unique_ptr<T2, D2>::pointer} is not implicitly
convertible to \tcode{CT}, the program is ill-formed.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{shared_ptr}}%
\indexlibrary{\idxcode{shared_ptr}!\idxcode{operator<=}}%
\begin{itemdecl}
template <class T1, class D1, class T2, class D2>
  bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(y < x)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator>}}%
\begin{itemdecl}
template <class T1, class D1, class T2, class D2>
  bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y < x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator>=}}%
\begin{itemdecl}
template <class T1, class D1, class T2, class D2>
  bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x < y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator==}}%
\begin{itemdecl}
template <class T, class D>
  bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;
template <class T, class D>
  bool operator==(nullptr_t, const unique_ptr<T, D>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class T, class D>
  bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;
template <class T, class D>
  bool operator!=(nullptr_t, const unique_ptr<T, D>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{(bool)x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator<}}%
\begin{itemdecl}
template <class T, class D>
  bool operator<(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
  bool operator<(nullptr_t, const unique_ptr<T, D>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The specialization \tcode{less<unique_ptr<T, D>::pointer>} shall be
a function object type~(\ref{function.objects}) that induces a strict weak
ordering~(\ref{alg.sorting}) on the pointer values.

\pnum
\returns
The first function template returns
\tcode{less<unique_ptr<T, D>::pointer>()(x.get(),\\nullptr)}.
The second function template returns
\tcode{less<unique_ptr<T, D>::pointer>()(nullptr, x.get())}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator>}}%
\begin{itemdecl}
template <class T, class D>
  bool operator>(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
  bool operator>(nullptr_t, const unique_ptr<T, D>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{nullptr < x}.
The second function template returns \tcode{x < nullptr}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator<=}}%
\begin{itemdecl}
template <class T, class D>
  bool operator<=(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
  bool operator<=(nullptr_t, const unique_ptr<T, D>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{!(nullptr < x)}.
The second function template returns \tcode{!(x < nullptr)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{unique_ptr}}%
\indexlibrary{\idxcode{unique_ptr}!\idxcode{operator>=}}%
\begin{itemdecl}
template <class T, class D>
  bool operator>=(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
  bool operator>=(nullptr_t, const unique_ptr<T, D>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The first function template returns \tcode{!(x < nullptr)}.
The second function template returns \tcode{!(nullptr < x)}.
\end{itemdescr}

