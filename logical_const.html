<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style type="text/css"></style></head>
    
<body><div><font size=-1>
<br>Doc number D3973
<br>2014-04-24
<br>Jonathan Coe &lt;<a href="mailto:jbcoe@me.com" target="_blank">jbcoe@me.com</a>&gt;
<br>Robert Mill &lt;<a href="mailto:rob.mill.uk@gmail.com" target="_blank">rob.mill.uk@gmail.com</a>&gt;
</font>
    
<H1>A Proposal to Add a Logical Const Wrapper to the Standard Library Technical Report</H1>

<H2>I. Introduction</H2>
<p>We propose the introduction of a <tt>logical_const</tt> wrapper class that propagates <tt>const</tt>-ness to pointer-like member variables.</p>
    
<H2>II. Motivation</H2>
<p>The behaviour of <tt>const</tt> member functions on objects with pointer-like data members is seen to be surprising by many practitioners of C++. A <tt>const</tt> member function can call non-<tt>const</tt> functions on pointer-like data members and will do so by default without use of <tt>const_cast</tt>; that is, <tt>const</tt> on member functions provides physical but not logical <tt>const</tt>-ness [1].</p>

<p><b>Example:</b></p>
    
<blockquote><tt><pre>
  struct A
  {
    void bar() const 
    { 
      std::cout &lt;&lt; "bar (const)" &lt;&lt; std::endl; 
    }
    
    void bar() 
    { 
      std::cout &lt;&lt; "bar (non-const)" &lt;&lt; std::endl; 
    }
  };

  struct B
  {
    B() : m_ptrA(std::make_unique&lt;A&gt;()) {} 
    
    void foo() const 
    { 
      std::cout &lt;&lt; "foo (const)" &lt;&lt; std::endl;
      m_ptrA->bar(); 
    }
    
    void foo() 
    { 
      std::cout &lt;&lt; "foo (non-const)" &lt;&lt; std::endl;
      m_ptrA->bar(); 
    }

    std::unique_ptr&lt;A&gt; m_ptrA;
  };

  int main()
  {    
    B b;
    b.foo();
    
    const B const_b;
    const_b.foo();
  }
  
</pre></tt></blockquote>

<p>Running this program gives the following output:</p>
<blockquote><tt><pre>
  foo (non-const)
  bar (non-const)
  foo (const)
  bar (non-const)
</pre></tt></blockquote>
    
<p>The behaviour above can be amended by re-writing <tt>void B::foo() const</tt> using <tt>const_cast</tt> to explicitly call the <tt>const</tt> member function of <tt>A</tt>. Such a change is unnatural and not common practice. We propose the introduction of a wrapper class which can be used on pointer-like member data to ensure propagation of logical <tt>const</tt>-ness.</p>
 
<h3>Introducing <tt>logical_const</tt></h3>

<p>The class <tt>logical_const</tt> is designed to function as closely as possible to a traditional pointer or smart-pointer. Pointer-like member objects can be wrapped in a <tt>logical_const</tt> object to ensure propagation of logical <tt>const</tt>-ness.</p> 
    
<p>A logically-<tt>const</tt> <tt>B</tt> would be written as</p>
<blockquote><tt><pre>
struct B
{
  B();              // unchanged
  
  void foo() const; // unchanged
  void foo();       // unchanged

  <font color=blue><b>std::logical_const&lt;</b></font>std::unique_ptr&lt;A&gt;<font color=blue><b>&gt;</b></font> m_ptrA;
};
</pre></tt></blockquote>

<p>With an amended <tt>B</tt>, running the program from the earlier example will give the following output:</p> 
<blockquote><tt><pre>
  foo (non-const)
  bar (non-const)
  foo (const)
  bar (const)
</pre></tt></blockquote>   
    
<h3>The pimpl idiom with <tt>logical_const</tt></h3>
<p>The pimpl (pointer-to-implementation) idiom pushes implementation details of a class into a separate object, a pointer to which is stored in the original class [2].</p>
    
<blockquote><tt><pre>class C
{
  void foo() const;
  void foo();
    
  std::unique_ptr&lt;CImpl&gt; m_pimpl;
};

void C::foo() const 
{ 
  m_pimpl->foo(); 
}

void C::foo() 
{ 
  m_pimpl->foo(); 
}

</pre></tt></blockquote> 
    
 <p>When using the pimpl idiom the compiler will not catch changes to member variables within <tt>const</tt> member functions. Member variables are kept in a separate object and the compiler only checks that the address of this object is unchanged. By introducing the pimpl idiom into a class to decouple interface and implementation, the author may have inadventantly lost compiler checks on <tt>const</tt>-correctness.</p>
<p>When the pimpl object is wrapped in <tt>logical_const</tt>, <tt>const</tt> member functions will only be able to call <tt>const</tt> functions on the pimpl object and will be unable to modify (non-<tt>mutable</tt>) member variables of the pimpl object without explicit <tt>const_cast</tt>s: <tt>const</tt>-correctness is restored. The class above would be modified as follows:</p>

<blockquote><tt><pre>class C
{
    void foo() const;  // unchanged
    void foo();        // unchanged
    
    <font color=blue><b>std::logical_const&lt;</b></font>std::unique_ptr&lt;CImpl&gt;<font color=blue><b>&gt;</b></font> m_pimpl;
};</pre></tt></blockquote> 
    
<h3>Thread safety and <tt>logical_const</tt></h3>
    
<H2>III. Impact On the Standard</H2>

<p>This proposal is a pure library extension. It does not require changes to any standard classes, functions or headers.</p>

<H2>IV. Design Decisions</H2>

<p>Given absolute freedom we would propose changing the <tt>const</tt> keyword to propagate logical-<tt>const</tt>-ness. That would be impractical, however, as it would break existing code and change behaviour in potentially undesirable ways. A second approach would be the introduction of a new keyword to modify <tt>const</tt>, for instance, <tt>logical const</tt>, which enforces logical-<tt>const</tt>-ness. Although this change would maintain backward-compatibility, it would require enhancements to the C++ compiler.</p>

<p>As an immediate alternative, we suggest that the standard library supply a class that wraps member data where logically-<tt>const</tt> behaviour is required. The <tt>logical_const</tt> wrapper can be used much like the <tt>const</tt> keyword and will cause compilation failure wherever logical-<tt>const</tt>-ness is violated. Logical-<tt>const</tt>-ness can be introduced into existing code by decorating pointer-like members of a class with <tt>logical_const</tt>.</p>
    
<p>The change required to introduce logical-<tt>const</tt>-ness to a class is simple and local enough to be enforced during code review and taught to C++ developers in the same way as smart-pointers are taught to ensure exception safety.</p>
    
<p>It is intended that <tt>logical_const</tt> contains no member data besides the wrapped pointer. Inlining of function calls by the compiler will ensure that using <tt>logical_const</tt> incurs no run-time cost.</p>

<h3>Encapsulation vs inheritance</h3>

Inheritance from the wrapped pointer-like object (where it is a class type) was considered but ruled out. The purpose of this wrapper is to help the author ensure logical <tt>const</tt>-ness; if <tt>logical_const&lt;T&gt;</tt> were to inherit from <tt>T</tt>, then it would allow potentially non-logical-<tt>const</tt> member functions of <tt>T</tt> to be called in a <tt>const</tt> context.
    
<h3>Construction and Assignment</h3>
<p> A <tt>logical_const&lt;T&gt;</tt> should be constructable and assignable from a <tt>U</tt> or a <tt>logical_const&lt;U&gt;</tt> where <tt>U</tt> is any type that <tt>T</tt> can be constructed or assigned from. For instance, a <tt>logical_const&lt;std::shared_ptr&lt;T&gt;&gt;</tt> can be constructed or assigned from a <tt>std::unique_ptr&lt;U&gt;</tt> where <tt>U</tt> is a sub-class of <tt>T</tt>.</p>

<h3>Pointer-like functions</h3>
<p><tt>operator*</tt> and <tt>operator-></tt> are defined to preserve logical <tt>const</tt>-ness. When a <tt>const</tt> <tt>logical_const&lt;T&gt;</tt> is used only <tt>const</tt> member functions of <tt>T</tt> can be used without explicit casts.</p>
    
<h3><tt>get()</tt></h3>
<p>The <tt>get()</tt> function returns the address of the object pointed to by the wrapped pointer. <tt>get()</tt> is intended to be used to ensure logical-<tt>const</tt>-ness is preserved when using interfaces which require raw C-style pointers</p>
    
<h3>Equality, inequality and comparison</h3>    
<p>Free-standing equality, inequality and comparison operators are provided so that a <tt>logical_const&lt;T&gt;</tt> can be used in any equality, inequality or comparison where a <tt>T</tt> could be used. Logical <tt>const</tt>-ness should not alter the result of any equality, inequality or comparison operation.</p>
    
<h3><tt>swap()</tt></h3>    
<p>The swap function should not add or remove logical <tt>const</tt>-ness but should not unduly restrict the types with which <tt>logical_const&lt;T&gt;</tt> can be swapped. If <tt>T</tt> and <tt>U</tt> can be swapped then logically-<tt>const</tt> <tt>T</tt> and <tt>U</tt> can be swapped.</p>
    
<h3><tt>cast_away_logical_const()</tt></h3>
<p>This free-standing function allows the underlying pointer to be accessed. The use of this function allows logical <tt>const</tt>-ness to be dropped and is therefore discouraged. The function is named such that it will be easy to find in code review.</p>
    
<H2>V. Technical Specifications</h2>    
    
<p>The proposed form of <tt>std::logical_const</tt> is given below. Implementation is exposition-only.</p>
    
<blockquote><tt><pre>
template &lt;typename T&gt;
class logical_const
{
public:

  typedef std::remove_reference_t&lt;decltype(*std::declval&lt;T&gt;())&gt; value_type;

  ~logical_const() 
  {
  }
  
  logical_const(): t{} 
  {
  }
  
  template &lt;typename U&gt;
  logical_const(U&& u) : t{std::forward&lt;U&gt;(u))} 
  {
  }

  template &lt;typename U&gt;
  logical_const&lt;T&gt;& operator = (U&& u) 
  { 
    t = std::forward&lt;U&gt;(u); 
    return *this; 
  }
  
  template &lt;typename U&gt;
  logical_const(const logical_const&lt;U&gt;& pu) : t{pu.t} {}
  
  template &lt;typename U&gt;
  logical_const(logical_const&lt;U&gt;&& pu) : t{std::move(pu.t)} {}
  
  
  template &lt;typename U&gt;
  logical_const&lt;T&gt;& operator = (const logical_const&lt;U&gt;& pt) 
  { 
    t = pt.t; 
    return *this; 
  }
  
  template &lt;typename U&gt;
  logical_const&lt;T&gt;& operator = (logical_const&lt;U&gt;&& pt) 
  { 
    t = std::move(pt.t); 
    return *this; 
  }
  
  value_type* operator->()
  {
    return std::addressof(*t);
  }

  const value_type* operator->() const
  {
    return std::addressof(*t);
  }
  
  value_type* get()
  {
    return std::addressof(*t);
  }

  const value_type* get() const
  {
    return std::addressof(*t);
  }
  
  value_type& operator*()
  {
    return *t;
  }

  const value_type& operator*() const
  {
    return *t;
  }
  
  operator bool () const
  {
    return t;
  }
  
private:
  T t;
};

template &lt;typename T, typename U&gt;
bool operator == (const logical_const&lt;T&gt;& pt, const logical_const&lt;U&gt;& pu)
{   
  return pt.t == pu.t; 
}
 
template &lt;typename T, typename U&gt;
bool operator != (const logical_const&lt;T&gt;& pt, const logical_const&lt;U&gt;& pu)
{   
  return pt.t != pu.t; 
}

template &lt;typename T, typename U&gt;
bool operator &lt; (const logical_const&lt;T&gt;& pt, const logical_const&lt;U&gt;& pu)
{   
  return pt.t &lt; pu.t; 
}

template &lt;typename T, typename U&gt;
bool operator == (const logical_const&lt;T&gt;& pt, const U& u)
{   
  return pt.t == u; 
}
 
template &lt;typename T, typename U&gt;
bool operator != (const logical_const&lt;T&gt;& pt, const U& u)
{   
  return pt.t != u; 
}

template &lt;typename T, typename U&gt;
bool operator &lt; (const logical_const&lt;T&gt;& pt, const U& u)
{   
  return pt.t &lt; u; 
}

template &lt;typename T, typename U&gt;
bool operator == (const T& t, const logical_const&lt;U&gt;& pu)
{   
  return t == pu.t; 
}
 
template &lt;typename T, typename U&gt;
bool operator != (const T& t, const logical_const&lt;U&gt;& pu)
{   
  return t != pu.t; 
}

template &lt;typename T, typename U&gt;
bool operator &lt; (const T& t, const logical_const&lt;U&gt;& pu)
{   
  return t &lt; pu.t; 
}

template &lt;typename T, typename U&gt;
void swap (logical_const&lt;T&gt;& pt1, logical_const&lt;U&gt;& pt2)
{   
  swap(pt1.t, pt2.t); 
}

template &lt;typename T&gt;
const T& cast_away_logical_const(const logical_const&lt;T&gt;& pt1)
{
  return pt1.t;
}

template &lt;typename T&gt;
T& cast_away_logical_const(logical_const&lt;T&gt;& pt1)
{
  return pt1.t;
}

</pre></tt></blockquote> 

<H2>VI Acknowledgements</H2>
<p>Thanks to Walter Brown, Nick Maclaren, Ville Voutilainen, Jonathan Wakely and others for helpful discussion.</p>

<H2>VII References</H2>
<ul>
  <li>[1] Bjarne Stroustrup, The C++ Programming Language, 4th edition, 2013,
          Addison Wesley ISBN-10: 0321563840 p464</li>

  <li>[2] Martin Reddy, API design for C++, 2011, Elsevier ISBN-10: 0123850037, Section 3.1</li>
</ul>

</div></body></html>
