<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>A Proposal to Add a Logical Const Wrapper to the Standard Library</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
</HEAD>
<BODY><FONT size=-1>
<BR>Doc number XXXX=XX-XX
<br>19 Apr 2014
<br>Jonathan Coe &lt;jbcoe@me.com&gt;
<br>Robert Mill &lt;rob.mill.uk@gmail.com&gt
</FONT>
    
<H1>A Proposal to Add a Logical Const Wrapper to the Standard Library Technical Report</H1>

<H2>I. Motivation</H2>
<p>The behaviour of <tt>const</tt> member functions with pointer-like data members is seen to be surprising by many practitioners of C++. A <tt>const</tt> member function can call non-<tt>const</tt> functions on pointer-like member data and will do so by default without use of <tt>const_cast</tt>: <tt>const</tt> on member functions provides bit-wise but not logical <tt>const</tt>-ness.</p>

<p><b>Example:</b></p>
    
<blockquote><tt><pre>
  struct A
  {
    void bar() const 
    { 
      std::cout &lt&lt "bar (const)" &lt&lt std::endl; 
    }
    
    void bar() 
    { 
      std::cout &lt&lt "bar (non-const)" &lt&lt std::endl; 
    }
  };

  struct B
  {
    B() : m_ptrA(std::make_unique&ltA&gt()) {} 
    
    void foo() const 
    { 
      std::cout &lt&lt "foo (const)" &lt&lt std::endl;
      m_ptrA->bar(); 
    }
    
    void foo() 
    { 
      std::cout &lt&lt "foo (non-const)" &lt&lt std::endl;
      m_ptrA->bar(); 
    }

    std::unique_ptr&ltA&gt m_ptrA;
  };

  int main()
  {    
    B b;
    b.foo();
    
    const B const_b;
    const_b.foo();
  }
  
</pre></tt></blockquote>

<p>Running this program gives the following output:</p>
<blockquote><tt><pre>
  foo (non-const)
  bar (non-const)
  foo (const)
  bar (non-const)
</pre></tt></blockquote>
    
<p>The behaviour above can be amended by re-writing <tt>void B::foo() const</tt> using <tt>const_cast</tt> to explicitly call the <tt>const</tt> member function of <tt>A</tt>. Such a change is unnatural and not common practice. We propose the introduction of a wrapper class which can be used on pointer-like member data to ensure propagation of logical <tt>const</tt>-ness.</p>
 
<h3>Introducing <tt>logical_const</tt></h3>
<p>The class <tt>logical_const</tt> is designed to function as closely as possible to a traditional pointer or smart-pointer. Pointer-like member objects can be wrapped in a <tt>logical_const</tt> wrapper to ensure propagation of logical <tt>const</tt>-ness.</p> 
    
<p>A logically-<tt>const</tt> <tt>B</tt> would be written as</p>
<blockquote><tt><pre>
struct B
{
  B();              // unchanged
  
  void foo() const; // unchanged
  
  void foo();       // unchanged

  std::logical_const&lt;std::unique_ptr&ltA&gt&gt m_ptrA;
};
</pre></tt></blockquote>

<p>With an amended <tt>B</tt>, running the program from the earlier example will give the following output:</p> 
<blockquote><tt><pre>
  foo (non-const)
  bar (non-const)
  foo (const)
  bar (const)
</pre></tt></blockquote>   
    
    
<H2>II. Impact On the Standard</H2>

<p>This proposal is a pure library extension. It does not require changes to any standard classes, functions or headers.</p>

<H2>III. Design Decisions</H2>

<p>Constructors and conversion operators are implicit to allow minimal disruption to additional code: logical-<tt>const</tt>-ness can be used much like the <tt>const</tt> keyword and will cause compilation failure (compared to the raw underlying pointer) only where logical-<tt>const</tt>-ness is violated. Logical-<tt>const</tt>-ness can be imparted upon existing code by decorating pointer-like members of a class with <tt>logical_const</tt></p>
    
    
<p>The change required to introduce logical-<tt>const</tt>-ness to a class is simple and local enough to be enforced during code review and taught to C++ developers in the same way as smart-pointers are taught to ensure exception safety.</p>
    
<p>It is intended that <tt>logical_const</tt> contains no member data besides the wrapped pointer. Combined with compiler inlining of function calls this will mean that there is no run-time cost to using <tt>logical_const</tt>.</p>

<H2>IV. Technical Specifications</h2>    
    
<p>The proposed form of <tt>std::logical_const</tt> is given below. Implementation is exposition-only.</p>    
    
<blockquote><tt><pre>
template &lttypename T&gt
class logical_const
{
public:

  typedef std::remove_reference_t&ltdecltype(*std::declval&ltT&gt())&gt Value_T;

  ~logical_const() {}
  
  logical_const() {}
  
  logical_const(const T& t_) : t{t_} {}
  
  logical_const(T&& t_) : t{std::move(t_)} {}

  logical_const(const logical_const&ltT&gt& pt_) : t{pt_.t} {}
  
  logical_const(logical_const&ltT&gt&& pt_) : t{std::move(pt_.t)} {}
  
  logical_const&ltT&gt& operator = (const T& t_) 
  { 
    t = t_; 
    return *this; 
  }
  
  logical_const&ltT&gt& operator = (T&& t_) 
  { 
    t = std::move(t_); 
    return *this; 
  }
  
  logical_const&ltT&gt& operator = (const logical_const&ltT&gt& pt_) 
  { 
    t = pt_.t; 
    return *this; 
  }
  
  logical_const&ltT&gt& operator = (logical_const&ltT&gt&& pt_) 
  { 
    t = std::move(pt_.t); 
    return *this; 
  }
  
  Value_T* operator->()
  {
    return &*t;
  }

  const Value_T* operator->() const
  {
    return &*t;
  }

  Value_T& operator*()
  {
    return *t;
  }

  const Value_T& operator*() const
  {
    return *t;
  }
  
  Value_T* get()
  {
    return t.get() ;
  }

  const Value_T* get() const
  {
    return t.get();
  }
  
  operator const T& () const
  {
    return t;
  }
  
  operator T& ()
  {
    return t;
  }
  
private:
  T t;

};

template &lttypename T, typename U&gt
bool operator == (const logical_const&ltT&gt& pt1, const logical_const&ltU&gt& pt2)
{   
  return pt1.t == pt2.t; 
}
 
template &lttypename T, typename U&gt
bool operator != (const logical_const&ltT&gt& pt1, const logical_const&ltU&gt& pt2)
{   
  return pt1.t != pt2.t; 
}

template &lttypename T, typename U&gt
void swap (logical_const&ltT&gt& pt1, logical_const&ltU&gt& pt2)
{   
  swap(pt1.t, pt2.t); 
}

</pre></tt></blockquote> 

<H2>V Acknowledgements</H2>
<p>Thanks to Walter Brown, Jonathan Wakely, Nick Maclaren and Beman Dawes for helpful discussion.</p>

<H2>VI References</H2>
<p>WORK NEEDED</p>

<ul>
</ul>

</BODY></HTML>
